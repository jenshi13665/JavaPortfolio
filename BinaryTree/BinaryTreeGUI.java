/*The following code sets up a GUI to create and categorize binary trees.
 * 
 *  *Name: Ingram, Chloe P		Date: 23 April 2022		Class: CMSC 350 - 7380
 */

import java.awt.Component;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextField;

public class BinaryTreeGUI extends JFrame{
	 private JTextField input = new JTextField(20), output = new JTextField(20);
	 private final JButton makeTree = new JButton("Make Tree");
	 private final JButton isBalanced = new JButton("is Balanced?");
	 private final JButton isFull = new JButton("is Full?");
	 private final JButton isProper = new JButton("is Proper?");
	 private final JButton height = new JButton("Height");
	 private final JButton inorder = new JButton("Inorder");
	 private BinaryTree currTree;

	 //The following method was adapted from Dr. Jarc, 
	 //and is used with their recommendation. 
	 public BinaryTreeGUI() {
	     super("Binary Tree Categorizer");
	     setSize(600, 150);
	     setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	     setLayout(new GridLayout(3, 1));
	     JComponent[] inputComponents = {new JLabel("Enter Tree"),
	             input};
	     makeFlowPanel(inputComponents);
	     JComponent[] buttonComponents = {makeTree, isBalanced,
	    		 isFull, isProper, height, inorder};
	     makeFlowPanel(buttonComponents);
	     JComponent[] outputComponents = {new JLabel("Output"), output};
	     makeFlowPanel(outputComponents);
	     output.setEditable(false);
	     makeTree.addActionListener(makeTreeListener);
	     isBalanced.addActionListener(isBalancedListener);
	     isFull.addActionListener(isFullListener);
	     isProper.addActionListener(isProperListener);
	     height.addActionListener(heightListener);
	     inorder.addActionListener(inorderListener);
	 }
	 
	 //The following method calls a method to convert from 
	 //prefix notation to postfix notation.
	 private final ActionListener makeTreeListener = event -> 
	 {
		 try {
			 	output.setText("");
	            String tree = input.getText();
	            currTree = new BinaryTree(tree);
	            output.setText("Tree Created.");
	        } catch (InvalidTreeSyntax e) {
	            JOptionPane.showMessageDialog(null, e.getMessage());
	        }
	 };
	 
	 //The following method calls a method to check if the binary tree is
	 //balanced.
	 private final ActionListener isBalancedListener = event -> 
	 {
		 output.setText("");
		 try {
			 if(currTree == null) {
				 throw new InvalidTreeSyntax("You must click Make Tree first.");
			 }
		 } catch (InvalidTreeSyntax e) {
			 JOptionPane.showMessageDialog(null, e.getMessage());
		 }
		 Boolean value = currTree.balanceCheck();
	     output.setText("" + value);
	 };
	 
	//The following method calls a method to check if the binary tree is
	//full.
	 private final ActionListener isFullListener = event -> 
	 {
		 output.setText("");
		 try {
			 if(currTree == null) {
				 throw new InvalidTreeSyntax("You must click Make Tree first.");
			 }
		 } catch (InvalidTreeSyntax e) {
			 JOptionPane.showMessageDialog(null, e.getMessage());
		 }
		 Boolean value = currTree.fullCheck();
	     output.setText("" + value);
	 };
	 
	//The following method calls a method to check if the binary tree's
	//height.
	 private final ActionListener heightListener = event -> 
	 {
		 output.setText("");
		 try {
			 if(currTree == null) {
				 throw new InvalidTreeSyntax("You must click Make Tree first.");
			 }
		 } catch (InvalidTreeSyntax e) {
			 JOptionPane.showMessageDialog(null, e.getMessage());
		 }
		 int value = currTree.heightCheck(currTree.root);
	     output.setText("" + value);
	 };
	 
	//The following method calls a method to check if the binary tree is
	//proper.
	 private final ActionListener isProperListener = event -> 
	 {
		 output.setText("");
		 try {
			 if(currTree == null) {
				 throw new InvalidTreeSyntax("You must click Make Tree first.");
			 }
		 } catch (InvalidTreeSyntax e) {
			 JOptionPane.showMessageDialog(null, e.getMessage());
		 }
		 Boolean value = currTree.properCheck(currTree.root);
	     output.setText("" + value);
	 };
	 
	//The following method calls a method to traverse the binary tree inorder.
	 private final ActionListener inorderListener = event -> 
	 {
		 output.setText("");
		 try {
			 if(currTree == null) {
				 throw new InvalidTreeSyntax("You must click Make Tree first.");
			 }
		 } catch (InvalidTreeSyntax e) {
			 JOptionPane.showMessageDialog(null, e.getMessage());
		 }
		 StringBuilder value = currTree.inorder();
	     output.setText(value.toString());
	 };
	 
	 
	 
	 //The following method was generated by Dr. Jarc, 
	 //and is used with their recommendation.
	 //It functions to create a FlowLayout-style GUI.
	 private void makeFlowPanel(JComponent[] components) {
	     JPanel panel = new JPanel();
	     panel.setLayout(new FlowLayout());
	     for (Component component : components)
	         panel.add(component);
	     add(panel);
	 }

	 //The main() method creates a new ConverterGUI.
	 public static void main(String[] args) {
	     BinaryTreeGUI frame = new BinaryTreeGUI();
	     frame.setVisible(true);
	     
	 }

	


}
